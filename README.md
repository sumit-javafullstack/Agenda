 
## ----------------SPRINGBOOT-----------------

### 1) SpringBoot Dependency Injection
##### Creation of custom beans
##### Access of spring managed beans
##### Qualifers to acces specific beand for more than 1 implementation

### 2) SpringBoot features
#####  Use lombok
#####  Jackson properties
#####  Spring Profile and specific properties files
#####  Different way of accessing properties file values
#####  Global Exceptional handling 
#####  Rest Template Configuration in monolithic application


### 3) SpringBoot CRUD Opertion
##### Entity Class and field naming convention 
##### JPA and Hibernate validation dependency
##### PUT along with exception handling
##### Cacheing
##### Pagenation for efficient way of searching and filtering
##### File upload and access //https://www.bezkoder.com/spring-boot-upload-file-database/

### 4) MicroServices Architecture with SpringBoot-2
##### Service Discovery
##### Load Balancing
##### API Gateway
##### Circuit Breakers and Resilience Patterns
##### Centralized Configuration
##### Distributed Tracing
##### Security and Authentication

### 5) Migrate a springboot application from http to https

### 6) Creating Client with Completeable Future and process improvemnet

### 7) Accessing more then one db

### 8) Unit Testing and Integration Testing using mockito

### 9) Kafka with below features:
#### Publish-Subscribe Messaging:
#####      Utilize Kafka's publish-subscribe model to enable multiple consumers to subscribe to the same topic and receive copies of messages.
#### Message Serialization:
#####      Configure message serialization and deserialization to convert complex data structures to and from the byte streams that Kafka uses for communication.
#### Message Partitioning:
#####      Use partitioning to distribute messages across multiple brokers for scalability and parallel processing. Implement custom partitioners if needed.
#### Consumer Groups:
#####      Utilize consumer groups to scale horizontally and distribute message processing workload across multiple instances of a consumer within the same consumer group.
#### Offset Management:
#####      Handle offset management to keep track of the position of the last consumed message in each partition. This ensures that consumers can resume from where they left off.
#### Dead Letter Queues:
#####      Implement dead letter queues or error-handling mechanisms for messages that couldn't be successfully processed by consumers.
#### Streams API:
#####      Leverage Kafka Streams to build event-driven applications that can process and transform streams of data in real-time.
#### Batch Processing:
#####      Use Kafka for batch processing scenarios by consuming messages from topics that store batches of data.

### 10) Spring Security with below features
##### JWT token implementation
##### Add logout functionality

## ------------DEVOPS----------------
### 1) Docker

## ------------FULL_STACK-------------
### 1) React
##### java script
##### React Life Cycle
##### etc
##### 2) Project on React and SpringBoot
##### 3) e-commerce application

## -------------CLOUD----------------
##### AWS
        
